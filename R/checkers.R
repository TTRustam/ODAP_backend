# TR: add some roxygen-style documentation to these,
# and a manifest here at the top

# This functions check the extension of the file provided by the user and the adequacy of the data in that file.
# currently only 4  file types are supported ".csv",".xlsx",".xls",".tsv"

#' Check the provided files extension.
#' @description 
#' @param user_file character. File name with corresponding extension e.g. Should be one of ".csv",".xlsx",".xls",".tsv"
#' @return A character string with the file extension.
#' @importFrom stringr str_detect 
#' @examples1
#' \dontrun{
#' extension_check(
#'     user_file = "data.csv")
#' }
extension_check <- function(user_file) { 
  # consider txt if it's delimited and reads correctly by read_delim()?
  # but we need to cathc failures intelligently in that case. A standard HMD
  # file would fail, for instance, but maybe it also should fail.
  allowable_extensions <- c("csv","xlsx","xls","tsv")
  ind                  <- str_detect(user_file, 
                                     pattern = paste0(".", allowable_extensions,"$"))
  allowable_extensions[ind]
}

# TR: note NA is the value we use for AgeInt in the open age group

#' Check if all columns are numeric.
#' @description 
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom purrr map 
#' @importFrom stringr str_flatten
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_numeric(
#'     data = data)
#' }
check_numeric <- function(data) { 
  
  isnumeric <- data %>%
    map(~ is.numeric(.)) %>% 
    unlist()
  
  if(sum(isnumeric) < ncol(data)) { 
    
    message <- paste0("Please check the input data. Every column should be numeric, while columns ",
                      str_flatten(names(data)[!isnumeric], collapse = ", "),
                      " are not.")
  } else { 
    
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check numeric", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}



#' Check if any of the crucial columns are missing.
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom stringr str_c str_flatten
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_missing_cols(
#'     data = data)
#' }
check_missing_cols <- function(data) { 
  # TR: DemoTools has the function age2int() to infer age intervals from an Age vector,
  # to technically we don't need it. We do however need ages specified as lower bounds of
  # abridged age groups (for the abridged lifetable function anyway). Let's not insist on
  # AgeInt being given.
  missing_cols <- setdiff(c("Deaths", "Exposures", "Age"), names(data))
  
  if(length(missing_cols) > 0) { 
    
    message <- str_c("The following columns are missing from the data:- ", 
                     str_flatten(missing_cols, collapse = ", "), 
                     ". The calculations are halted.")
    
  } else { 
    
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check missing columns", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}


#' Check number of rows in the data.
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_rows(
#'     data = data)
#' }
check_rows <- function(data) { 
  
  if(nrow(data) < 10) { 
    
    message <- "The number of rows in the datast is less than expected. Please check the data before proceeding with calculations"
    
  } else { 
    
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check number of rows", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

# retired, now that we have a flexible lifetable function
# check_abridged <- function(data) { 
#   
#   if(!(is_abridged(data$Age))) {
#     
#     stop("You vector of ages is not of the lower bounds of abridged age groups. Please fix the data before proceeeding")
#     
#   }
#   
# }

# TR: needs to be modified to allow NA in final position of AgeInt, if there is 
# an AgeInt column...


#' Check if there is na clues in any of the columns.
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom stringr str_c str_flatten
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_nas(
#'     data = data)
#' }
check_nas <- function(data) { 
  
  if(any(names(data) == "AgeInt") & is.na(last(data$AgeInt)) & sum(is.na(data$AgeInt)) == 1) { 
    
    nas <- data |>
      subset(select = -AgeInt) |>  
      is.na() |>
      colSums()
    
  } else { 
    
    nas <- data |>
      is.na() |>
      colSums()
    
  }
  
  if(sum(nas) > 0) { 
    
    message <- str_c("Following columns have missing data:- ",
                     str_flatten(names(nas)[nas > 0], collapse = ", "),
                     ", n = ",
                     str_flatten(nas[nas > 0], collapse = ", "),
                     ". Please ensure there are no mistakes.")
  } else { 
    
    message <- NA_character_
    
  }
  
  res <- data.frame(check = "check missing rows", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

# TR: see also DemoTools functions:
# is_age_coherent()
# For the next 3 functions we can simply copy the description files from DemoTools. All they do is calling the DemoTools functions.

# Check for coherence within Age and between Age and AgeInt
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom DemoTools is_age_coherent
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_coherent(
#'     data = data)
#' }
check_coherent <- function(data) { 
  
  tst <- is_age_coherent(data$Age, data$AgeInt)
  
  if(!tst) {
    
    message <- "The age is not coherent."
    
  } else { 
    
    message <- NA_character_
    
  }
  
  res <- data.frame(check = "check age coherency", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

# Checks if Age is sorted sequentially?
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom DemoTools is_age_sequential
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_sequential(
#'     data = data)
#' }
check_sequential <- function(data) { 
  
  tst <- is_age_sequential(data$Age)
  
  if(!tst) {
    
    message <- "The age is not sequential"
    
  } else { 
    
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check age sequential", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

# is_age_redundant()
# Check for redundant age specification
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom DemoTools is_age_redundant
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' is_age_redundant(
#'     data = data)
#' }
check_redundant <- function(data) { 
  
  tst <- is_age_redundant(data$Age, data$AgeInt)
  
  if(tst) {
    
    message <- "Provided age data is redundadt"
    
  } else { 
    
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check age redundancy", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}
# TR add a check that the lowest age is 0. 

#' Check if ages start with 0.
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_lower(
#'     data = data)
#' }
check_lower <- function(data) { 
  
  if(min(data$Age) != 0) { 
    
    message <- "Age should start with 0."
    
  } else { 
    
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check age redundancy", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

# Currently the lt_abridged function assumes this,
# although it would be nice to generalize it to allow for truncated age ranges.
# TR: check_abridged() only relevant for lt_abridged(), so that can happen elsewhere.
# not sure it is needed. Maybe better display line by line. This combines them all


#' Upper level function that checks the data quality. Checks if the columns are numeric, if any of the columns is missing, if there is insufficint rows, if there are mising data enties, if ages do not start with 0, and also if ages are coherent, sequential and not redundand.
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns and results of 8 tests: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom stringr str_c str_detect str_flatten
#' @importFrom DemoTools is_age_redundant is_age_sequential is_age_coherent 
#' @importFrom purrr map 
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_data(
#'     data = data)
#' }

# make this return a data.frame with 3 columns
# check | pass/fail | message
# don't use stop or errors for these
check_data <- function(data) { 
  
  ch1 <- check_numeric(data)
  ch2 <- check_missing_cols(data)
  ch3 <- check_rows(data)
  ch4 <- check_nas(data)
  ch5 <- check_lower(data)
  ch6 <- check_coherent(data)
  ch7 <- check_sequential(data)
  ch8 <- check_redundant(data)
  
  return(rbind(ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8))
}
