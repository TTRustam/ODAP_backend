# TR: add some roxygen-style documentation to these,
# and a manifest here at the top

# This functions check the extension of the file provided by the user and the adequacy of the data in that file.
# currently only 4  file types are supported ".csv",".xlsx",".xls",".tsv"


#' Check the provided files extension.
#' @description 
#' @param user_file character. File name with corresponding extension e.g. Should be one of ".csv",".xlsx",".xls",".tsv"
#' @return A character string with the file extension.
#' @importFrom stringr str_detect 
#' @examples1
#' \dontrun{
#' extension_check(
#'     user_file = "data.csv")
#' }
extension_check <- function(user_file) { 
  # consider txt if it's delimited and reads correctly by read_delim()?
  # but we need to cathc failures intelligently in that case. A standard HMD
  # file would fail, for instance, but maybe it also should fail.
  allowable_extensions <- c("csv","xlsx","xls","tsv")
  ind                  <- str_detect(user_file, 
                                     pattern = paste0(".", allowable_extensions,"$"))
  allowable_extensions[ind]
}

# TR: note NA is the value we use for AgeInt in the open age group

#' Check if all columns are numeric.
#' @description 
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return An error if any of the four columns is not numeric.
#' @importFrom purrr map 
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_numeric(
#'     data = data)
#' }
check_numeric <- function(data) { 
  
  isnumeric <- data %>%
    map(~ is.numeric(.)) %>% 
    unlist()
  
  if(sum(isnumeric) < 4) { 
    
    stop("Please check the input data. Every column should be numeric, while columns", " are not.")
    
  }
  
}

#' Check if any of the crucial columns are missing.
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return An error and a message if any of the three crucial columns are missing. These columns are: Deaths, Exposures, Age
#' @importFrom stringr str_c 
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_missing_cols(
#'     data = data)
#' }
check_missing_cols <- function(data) { 
  # TR: DemoTools has the function age2int() to infer age intervals from an Age vector,
  # to technically we don't need it. We do however need ages specified as lower bounds of
  # abridged age groups (for the abridged lifetable function anyway). Let's not insist on
  # AgeInt being given.
  missing_cols <- setdiff(c("Deaths", "Exposures","Age"), names(data))
  
  if(ncol(data) < 4) { 
    
    
    stop(str_c("The following columns are missing from the data:- ", missing_cols, ". The calculations are halted."))
    
  }
  
}


#' Check number of rows in the data.
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return An error and a message if the number of rows is less than 10. 
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_rows(
#'     data = data)
#' }
check_rows <- function(data) { 
  
  if(nrow(data) < 10) { 
    
    stop("The number of rows in the datast is less than expected. Please check the data before proceeding with calculations")
    
  }
  
}

# retired, now that we have a flexible lifetable function
# check_abridged <- function(data) { 
#   
#   if(!(is_abridged(data$Age))) {
#     
#     stop("You vector of ages is not of the lower bounds of abridged age groups. Please fix the data before proceeeding")
#     
#   }
#   
# }

# TR: needs to be modified to allow NA in final position of AgeInt, if there is 
# an AgeInt column...


#' Check if there is na clues in any of the columns.
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return An error and an information on how many NA values are detected in a problematic column. This function allows for a NA value to be recorded in OAG in AgeInt column
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_nas(
#'     data = data)
#' }
check_nas <- function(data) { 
  
  if(any(names(data) == "AgeInt") & is.na(last(data$AgeInt)) & sum(is.na(data$AgeInt)) == 1) { 
    
    nas <- data |>
      subset(select = -AgeInt) |>  
      is.na() |>
      colSums()
    
  } else { 
    
    nas <- data |> 
      is.na() |>
      colSums()
    
  }
  
  if(sum(nas) > 0) { 
    stop("Following columns have missing data:- ", 
         names(data)[nas > 0],
         ", n = ",
         nas[nas > 0],
         ". Please ensure there are no mistakes.")
  }
  
}

# TR: see also DemoTools functions:
# is_age_coherent()
# For the next 3 functions we can simply copy the description files from DemoTools. All they do is calling the DemoTools functions.

# Check for coherence within Age and between Age and AgeInt
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return An error if the arguments are considered consistent.
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_coherent(
#'     data = data)
#' }
check_coherent <- function(data) { 
  
  tst <- is_age_coherent(data$Age, data$AgeInt)
  
  stopifnot("The age is not coherent" = tst)
  
}

# Checks if Age is sorted sequentially?
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return An error if the Age vector is not sorted sequentially
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_sequential(
#'     data = data)
#' }
check_sequential <- function(data) { 
  
  tst <- is_age_sequential(data$Age)
  
  stopifnot("The age is not sequential" = tst)
  
}

# is_age_redundant()
# Check for redundant age specification
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return An error if there are repeated values in the Age vector.
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' is_age_redundant(
#'     data = data)
#' }
check_redundant <- function(data) { 
  
  tst <- is_age_redundant(data$Age, data$AgeInt)
  
  stopifnot("Provided age data is redundadt" = !tst)
  
}

# TR add a check that the lowest age is 0. 

#' Check if ages start with 0.
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return An error and a message if the ages do not starts at 0. 
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_lower(
#'     data = data)
#' }
check_lower <- function(data) { 
  
  stopifnot("Age should start with 0." = min(data$Age) == 0)
  
}

# Currently the lt_abridged function assumes this,
# although it would be nice to generalize it to allow for truncated age ranges.
# TR: check_abridged() only relevant for lt_abridged(), so that can happen elsewhere.
# not sure it is needed. Maybe better display line by line. This combines them all


#' Upper level function that checks the data quality. Checks if the columns are numeric, if any of the columns is missing, if there is insufficint rows, if there are mising data enties, if ages do not start with 0, and also if ages are coherent, sequential and not redundand.
#' @description
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return An error and a message if any of the conditions do not match.
#' @importFrom stringr str_c str_detect
#' @importFrom DemoTools is_age_redundant is_age_sequential is_age_coherent 
#' @importFrom purrr map 
#' @examples1
#' \dontrun{
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths, 
#'                        Exposures = Exposures, 
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_data(
#'     data = data)
#' }
check_data <- function(data) { 
  
  check_numeric(data)
  check_missing_cols(data)
  check_rows(data)
  # check_abridged(data) # replace it or remove
  check_nas(data)
  check_lower(data)
  check_coherent(data)
  check_sequential(data)
  check_redundant(data)
}
